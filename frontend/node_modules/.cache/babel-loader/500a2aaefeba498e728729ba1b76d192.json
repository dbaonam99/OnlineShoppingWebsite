{"ast":null,"code":"(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports', './windowOrGlobal'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('./windowOrGlobal'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.windowOrGlobal);\n    global.ScriptCache = mod.exports;\n  }\n})(this, function (exports, window) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  var counter = 0;\n  var scriptMap = typeof window !== 'undefined' && window._scriptMap || new Map();\n\n  var ScriptCache = exports.ScriptCache = function (global) {\n    global._scriptMap = global._scriptMap || scriptMap;\n    return function ScriptCache(scripts) {\n      var Cache = {};\n\n      Cache._onLoad = function (key) {\n        return function (cb) {\n          var registered = true;\n\n          function unregister() {\n            registered = false;\n          }\n\n          var stored = scriptMap.get(key);\n\n          if (stored) {\n            stored.promise.then(function () {\n              if (registered) {\n                stored.error ? cb(stored.error) : cb(null, stored);\n              }\n\n              return stored;\n            }).catch(function (error) {\n              return cb(error);\n            });\n          } else {// TODO:\n          }\n\n          return unregister;\n        };\n      };\n\n      Cache._scriptTag = function (key, src) {\n        if (!scriptMap.has(key)) {\n          // Server side rendering environments don't always have access to the `document` global.\n          // In these cases, we're not going to be able to return a script tag, so just return null.\n          if (typeof document === 'undefined') return null;\n          var tag = document.createElement('script');\n          var promise = new Promise(function (resolve, reject) {\n            var body = document.getElementsByTagName('body')[0];\n            tag.type = 'text/javascript';\n            tag.async = false; // Load in order\n\n            var cbName = 'loaderCB' + counter++ + Date.now();\n            var cb = void 0;\n\n            var handleResult = function handleResult(state) {\n              return function (evt) {\n                var stored = scriptMap.get(key);\n\n                if (state === 'loaded') {\n                  stored.resolved = true;\n                  resolve(src); // stored.handlers.forEach(h => h.call(null, stored))\n                  // stored.handlers = []\n                } else if (state === 'error') {\n                  stored.errored = true; // stored.handlers.forEach(h => h.call(null, stored))\n                  // stored.handlers = [];\n\n                  reject(evt);\n                }\n\n                stored.loaded = true;\n                cleanup();\n              };\n            };\n\n            var cleanup = function cleanup() {\n              if (global[cbName] && typeof global[cbName] === 'function') {\n                global[cbName] = null;\n                delete global[cbName];\n              }\n            };\n\n            tag.onload = handleResult('loaded');\n            tag.onerror = handleResult('error');\n\n            tag.onreadystatechange = function () {\n              handleResult(tag.readyState);\n            }; // Pick off callback, if there is one\n\n\n            if (src.match(/callback=CALLBACK_NAME/)) {\n              src = src.replace(/(callback=)[^\\&]+/, '$1' + cbName);\n              cb = window[cbName] = tag.onload;\n            } else {\n              tag.addEventListener('load', tag.onload);\n            }\n\n            tag.addEventListener('error', tag.onerror);\n            tag.src = src;\n            body.appendChild(tag);\n            return tag;\n          });\n          var initialState = {\n            loaded: false,\n            error: false,\n            promise: promise,\n            tag: tag\n          };\n          scriptMap.set(key, initialState);\n        }\n\n        return scriptMap.get(key).tag;\n      }; // let scriptTags = document.querySelectorAll('script')\n      //\n      // NodeList.prototype.filter = Array.prototype.filter;\n      // NodeList.prototype.map = Array.prototype.map;\n      // const initialScripts = scriptTags\n      //   .filter(s => !!s.src)\n      //   .map(s => s.src.split('?')[0])\n      //   .reduce((memo, script) => {\n      //     memo[script] = script;\n      //     return memo;\n      //   }, {});\n\n\n      Object.keys(scripts).forEach(function (key) {\n        var script = scripts[key];\n        var tag = window._scriptMap.has(key) ? window._scriptMap.get(key).tag : Cache._scriptTag(key, script);\n        Cache[key] = {\n          tag: tag,\n          onLoad: Cache._onLoad(key)\n        };\n      });\n      return Cache;\n    };\n  }(window);\n\n  exports.default = ScriptCache;\n});","map":{"version":3,"sources":["/Users/namduong/Documents/dev/shop-project/node_modules/google-maps-react/dist/lib/ScriptCache.js"],"names":["global","factory","define","amd","exports","require","mod","windowOrGlobal","ScriptCache","window","Object","defineProperty","value","counter","scriptMap","_scriptMap","Map","scripts","Cache","_onLoad","key","cb","registered","unregister","stored","get","promise","then","error","catch","_scriptTag","src","has","document","tag","createElement","Promise","resolve","reject","body","getElementsByTagName","type","async","cbName","Date","now","handleResult","state","evt","resolved","errored","loaded","cleanup","onload","onerror","onreadystatechange","readyState","match","replace","addEventListener","appendChild","initialState","set","keys","forEach","script","onLoad","default"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define(['exports', './windowOrGlobal'], factory);\n    } else if (typeof exports !== \"undefined\") {\n        factory(exports, require('./windowOrGlobal'));\n    } else {\n        var mod = {\n            exports: {}\n        };\n        factory(mod.exports, global.windowOrGlobal);\n        global.ScriptCache = mod.exports;\n    }\n})(this, function (exports, window) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    var counter = 0;\n    var scriptMap = typeof window !== 'undefined' && window._scriptMap || new Map();\n    var ScriptCache = exports.ScriptCache = function (global) {\n        global._scriptMap = global._scriptMap || scriptMap;\n        return function ScriptCache(scripts) {\n            var Cache = {};\n\n            Cache._onLoad = function (key) {\n                return function (cb) {\n                    var registered = true;\n\n                    function unregister() {\n                        registered = false;\n                    }\n\n                    var stored = scriptMap.get(key);\n\n                    if (stored) {\n                        stored.promise.then(function () {\n                            if (registered) {\n                                stored.error ? cb(stored.error) : cb(null, stored);\n                            }\n\n                            return stored;\n                        }).catch(function (error) {\n                            return cb(error);\n                        });\n                    } else {\n                        // TODO:\n                    }\n\n                    return unregister;\n                };\n            };\n\n            Cache._scriptTag = function (key, src) {\n                if (!scriptMap.has(key)) {\n                    // Server side rendering environments don't always have access to the `document` global.\n                    // In these cases, we're not going to be able to return a script tag, so just return null.\n                    if (typeof document === 'undefined') return null;\n\n                    var tag = document.createElement('script');\n                    var promise = new Promise(function (resolve, reject) {\n                        var body = document.getElementsByTagName('body')[0];\n\n                        tag.type = 'text/javascript';\n                        tag.async = false; // Load in order\n\n                        var cbName = 'loaderCB' + counter++ + Date.now();\n                        var cb = void 0;\n\n                        var handleResult = function handleResult(state) {\n                            return function (evt) {\n                                var stored = scriptMap.get(key);\n                                if (state === 'loaded') {\n                                    stored.resolved = true;\n                                    resolve(src);\n                                    // stored.handlers.forEach(h => h.call(null, stored))\n                                    // stored.handlers = []\n                                } else if (state === 'error') {\n                                    stored.errored = true;\n                                    // stored.handlers.forEach(h => h.call(null, stored))\n                                    // stored.handlers = [];\n                                    reject(evt);\n                                }\n                                stored.loaded = true;\n\n                                cleanup();\n                            };\n                        };\n\n                        var cleanup = function cleanup() {\n                            if (global[cbName] && typeof global[cbName] === 'function') {\n                                global[cbName] = null;\n                                delete global[cbName];\n                            }\n                        };\n\n                        tag.onload = handleResult('loaded');\n                        tag.onerror = handleResult('error');\n                        tag.onreadystatechange = function () {\n                            handleResult(tag.readyState);\n                        };\n\n                        // Pick off callback, if there is one\n                        if (src.match(/callback=CALLBACK_NAME/)) {\n                            src = src.replace(/(callback=)[^\\&]+/, '$1' + cbName);\n                            cb = window[cbName] = tag.onload;\n                        } else {\n                            tag.addEventListener('load', tag.onload);\n                        }\n                        tag.addEventListener('error', tag.onerror);\n\n                        tag.src = src;\n                        body.appendChild(tag);\n\n                        return tag;\n                    });\n                    var initialState = {\n                        loaded: false,\n                        error: false,\n                        promise: promise,\n                        tag: tag\n                    };\n                    scriptMap.set(key, initialState);\n                }\n                return scriptMap.get(key).tag;\n            };\n\n            // let scriptTags = document.querySelectorAll('script')\n            //\n            // NodeList.prototype.filter = Array.prototype.filter;\n            // NodeList.prototype.map = Array.prototype.map;\n            // const initialScripts = scriptTags\n            //   .filter(s => !!s.src)\n            //   .map(s => s.src.split('?')[0])\n            //   .reduce((memo, script) => {\n            //     memo[script] = script;\n            //     return memo;\n            //   }, {});\n\n            Object.keys(scripts).forEach(function (key) {\n                var script = scripts[key];\n\n                var tag = window._scriptMap.has(key) ? window._scriptMap.get(key).tag : Cache._scriptTag(key, script);\n\n                Cache[key] = {\n                    tag: tag,\n                    onLoad: Cache._onLoad(key)\n                };\n            });\n\n            return Cache;\n        };\n    }(window);\n\n    exports.default = ScriptCache;\n});"]},"metadata":{},"sourceType":"script"}