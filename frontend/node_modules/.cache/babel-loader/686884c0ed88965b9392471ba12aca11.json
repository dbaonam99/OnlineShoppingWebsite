{"ast":null,"code":"/* eslint no-unused-vars: \"off\" */\nexport default function slideToClosest(speed, runCallbacks, internal, threshold) {\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  if (threshold === void 0) {\n    threshold = 0.5;\n  }\n\n  var swiper = this;\n  var index = swiper.activeIndex;\n  var skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n  if (translate >= swiper.snapGrid[snapIndex]) {\n    // The current translate is on or after the current snap index, so the choice\n    // is between the current index and the one after it.\n    var currentSnap = swiper.snapGrid[snapIndex];\n    var nextSnap = swiper.snapGrid[snapIndex + 1];\n\n    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    // The current translate is before the current snap index, so the choice\n    // is between the current index and the one before it.\n    var prevSnap = swiper.snapGrid[snapIndex - 1];\n    var _currentSnap = swiper.snapGrid[snapIndex];\n\n    if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}","map":{"version":3,"sources":["/Users/namduong/Documents/dev/shop-project/node_modules/swiper/esm/components/core/slide/slideToClosest.js"],"names":["slideToClosest","speed","runCallbacks","internal","threshold","params","swiper","index","activeIndex","skip","Math","min","slidesPerGroupSkip","snapIndex","floor","slidesPerGroup","translate","rtlTranslate","snapGrid","currentSnap","nextSnap","prevSnap","_currentSnap","max","slidesGrid","length","slideTo"],"mappings":"AAAA;AACA,eAAe,SAASA,cAAT,CAAwBC,KAAxB,EAA+BC,YAA/B,EAA6CC,QAA7C,EAAuDC,SAAvD,EAAkE;AAC/E,MAAIH,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpBA,IAAAA,KAAK,GAAG,KAAKI,MAAL,CAAYJ,KAApB;AACD;;AAED,MAAIC,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAC3BA,IAAAA,YAAY,GAAG,IAAf;AACD;;AAED,MAAIE,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxBA,IAAAA,SAAS,GAAG,GAAZ;AACD;;AAED,MAAIE,MAAM,GAAG,IAAb;AACA,MAAIC,KAAK,GAAGD,MAAM,CAACE,WAAnB;AACA,MAAIC,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASL,MAAM,CAACD,MAAP,CAAcO,kBAAvB,EAA2CL,KAA3C,CAAX;AACA,MAAIM,SAAS,GAAGJ,IAAI,GAAGC,IAAI,CAACI,KAAL,CAAW,CAACP,KAAK,GAAGE,IAAT,IAAiBH,MAAM,CAACD,MAAP,CAAcU,cAA1C,CAAvB;AACA,MAAIC,SAAS,GAAGV,MAAM,CAACW,YAAP,GAAsBX,MAAM,CAACU,SAA7B,GAAyC,CAACV,MAAM,CAACU,SAAjE;;AAEA,MAAIA,SAAS,IAAIV,MAAM,CAACY,QAAP,CAAgBL,SAAhB,CAAjB,EAA6C;AAC3C;AACA;AACA,QAAIM,WAAW,GAAGb,MAAM,CAACY,QAAP,CAAgBL,SAAhB,CAAlB;AACA,QAAIO,QAAQ,GAAGd,MAAM,CAACY,QAAP,CAAgBL,SAAS,GAAG,CAA5B,CAAf;;AAEA,QAAIG,SAAS,GAAGG,WAAZ,GAA0B,CAACC,QAAQ,GAAGD,WAAZ,IAA2Bf,SAAzD,EAAoE;AAClEG,MAAAA,KAAK,IAAID,MAAM,CAACD,MAAP,CAAcU,cAAvB;AACD;AACF,GATD,MASO;AACL;AACA;AACA,QAAIM,QAAQ,GAAGf,MAAM,CAACY,QAAP,CAAgBL,SAAS,GAAG,CAA5B,CAAf;AACA,QAAIS,YAAY,GAAGhB,MAAM,CAACY,QAAP,CAAgBL,SAAhB,CAAnB;;AAEA,QAAIG,SAAS,GAAGK,QAAZ,IAAwB,CAACC,YAAY,GAAGD,QAAhB,IAA4BjB,SAAxD,EAAmE;AACjEG,MAAAA,KAAK,IAAID,MAAM,CAACD,MAAP,CAAcU,cAAvB;AACD;AACF;;AAEDR,EAAAA,KAAK,GAAGG,IAAI,CAACa,GAAL,CAAShB,KAAT,EAAgB,CAAhB,CAAR;AACAA,EAAAA,KAAK,GAAGG,IAAI,CAACC,GAAL,CAASJ,KAAT,EAAgBD,MAAM,CAACkB,UAAP,CAAkBC,MAAlB,GAA2B,CAA3C,CAAR;AACA,SAAOnB,MAAM,CAACoB,OAAP,CAAenB,KAAf,EAAsBN,KAAtB,EAA6BC,YAA7B,EAA2CC,QAA3C,CAAP;AACD","sourcesContent":["/* eslint no-unused-vars: \"off\" */\nexport default function slideToClosest(speed, runCallbacks, internal, threshold) {\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  if (threshold === void 0) {\n    threshold = 0.5;\n  }\n\n  var swiper = this;\n  var index = swiper.activeIndex;\n  var skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n  if (translate >= swiper.snapGrid[snapIndex]) {\n    // The current translate is on or after the current snap index, so the choice\n    // is between the current index and the one after it.\n    var currentSnap = swiper.snapGrid[snapIndex];\n    var nextSnap = swiper.snapGrid[snapIndex + 1];\n\n    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    // The current translate is before the current snap index, so the choice\n    // is between the current index and the one before it.\n    var prevSnap = swiper.snapGrid[snapIndex - 1];\n    var _currentSnap = swiper.snapGrid[snapIndex];\n\n    if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}"]},"metadata":{},"sourceType":"module"}